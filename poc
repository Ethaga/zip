// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.0;
import "forge-std/Test.sol";

contract SpreadParsing {
    // The vulnerable parsing pattern (mirrors the repo code)
    // input: spreads as uint256 mask, where each pair occupies 16 bits
    function parseBad(uint256 mask) public pure returns (uint32 low, uint32 high, uint256 rest) {
        // emulate single iteration of the original loop:
        low = uint32(mask & 0xFF);
        high = uint32((mask & 0xFF00) >> 8);
        rest = (mask >> 16);
    }

    // correct parsing if we intended 16-bit per id
    function parseGood(uint256 mask) public pure returns (uint32 low, uint32 high, uint256 rest) {
        low = uint32(mask & 0xFFFF);
        high = uint32((mask >> 16) & 0xFFFF);
        rest = (mask >> 32);
    }
}

contract SpreadParsingTest is Test {
    SpreadParsing s;

    function setUp() public {
        s = new SpreadParsing();
    }

    function testTruncationShowsMismatch() public {
        uint32 spotId = 256; // 0x0100
        uint32 perpId = 512; // 0x0200
        // Suppose the intended packed pair is (perp<<16) | spot
        uint256 packed = (uint256(perpId) << 16) | uint256(spotId);

        (uint32 badLow, uint32 badHigh, ) = s.parseBad(packed);
        (uint32 goodLow, uint32 goodHigh, ) = s.parseGood(packed);

        // Good parsing should match original IDs
        assertEq(goodLow, spotId);
        assertEq(goodHigh, perpId);

        // Bad parsing truncates
        assertTrue(badLow != goodLow || badHigh != goodHigh, "Bad parsing should differ");

        emit log_named_uint("spotId", spotId);
        emit log_named_uint("perpId", perpId);
        emit log_named_uint("badLow", badLow);
        emit log_named_uint("badHigh", badHigh);
        emit log_named_uint("goodLow", goodLow);
        emit log_named_uint("goodHigh", goodHigh);
    }
}
